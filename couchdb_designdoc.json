{
  "docs": [
    {
      "_id": "rphistory",
      "language": "javascript",
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "views": {
        "account_tx": {
          "map": "function (doc) {\n    for (var t = 0, txs = doc.transactions.length; t < txs; t++) {\n        var tx = doc.transactions[t];\n\n        emit(tx.Account, tx);\n\n    }\n}"
        },
        "count": {
          "map": "function(doc) {\n  var date = new Date(doc.close_time_timestamp),\n      key = [null, date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours()],\n      transactions = doc.transactions;\n\n  for (var i = 0, n = transactions.length; i < n; ++i) {\n    var t = transactions[i],\n        type = t.TransactionType;\n    if (!type) continue;\n    var currency = type === \"Payment\" ? symbol(t.Amount)\n          : type === \"TrustSet\" ? symbol(t.LimitAmount)\n          : type === \"OfferCreate\" ? symbol(t.TakerPays) + \"/\" + symbol(t.TakerGets)\n          : null;\n    if (currency == null) continue;\n    var k = key.slice();\n    k[0] = type;\n    emit(k, currency);\n  }\n}\n\nfunction symbol(d) {\n  return d.currency || \"XRP\";\n}",
          "reduce": "function(keys, values, rereduce) {\n  var counts = {};\n  if (rereduce) for (var i = 0, n = values.length; i < n; ++i) {\n    var value = values[i];\n    for (var key in value) {\n      if (counts.hasOwnProperty(key)) counts[key] += value[key];\n      else counts[key] = value[key];\n    }\n  } else for (var i = 0, n = values.length; i < n; ++i) {\n    var key = values[i];\n    if (counts.hasOwnProperty(key)) ++counts[key];\n    else counts[key] = 1;\n  }\n  return counts;\n}"
        },
        "offersExercised": {
          "map": "function(doc) {\n\n    var time = new Date(doc.close_time_timestamp),\n        datetime = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(), time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()]; // include time.getUTCMinutes(), time.getUTCSeconds() for greater granularity\n\n    for (var t = 0, txs = doc.transactions.length; t < txs; t++) {\n\n        if (doc.transactions[t].TransactionType === \"Payment\" || doc.transactions[t].TransactionType === \"OfferCreate\") {\n\n            var tx = doc.transactions[t],\n                meta = tx.metaData,\n                affNodes = meta.AffectedNodes;\n\n            for (var n = 0, num_nodes = affNodes.length; n < num_nodes; n++) {\n                var node;\n\n                if (affNodes[n].hasOwnProperty(\"ModifiedNode\") && affNodes[n].ModifiedNode.LedgerEntryType === \"Offer\") {\n                    node = affNodes[n].ModifiedNode;\n                } else if (affNodes[n].hasOwnProperty(\"DeletedNode\") && affNodes[n].DeletedNode.LedgerEntryType === \"Offer\") {\n                    node = affNodes[n].DeletedNode;\n                } else {\n                    continue;\n                }\n\n                if (node.PreviousFields.hasOwnProperty(\"TakerPays\") && node.PreviousFields.hasOwnProperty(\"TakerGets\")) {\n\n                    var pay_curr, pay_amnt;\n                    if (typeof node.PreviousFields.TakerPays === \"object\") {\n                        pay_curr = [node.PreviousFields.TakerPays.currency, node.PreviousFields.TakerPays.issuer];\n                        pay_amnt = node.PreviousFields.TakerPays.value - node.FinalFields.TakerPays.value;\n                    } else {\n                        pay_curr = [\"XRP\"];\n                        pay_amnt = (node.PreviousFields.TakerPays - node.FinalFields.TakerPays) / 1000000; // convert from drops\n                    }\n\n                    var get_curr, get_amnt;\n                    if (typeof node.PreviousFields.TakerGets === \"object\") {\n                        get_curr = [node.PreviousFields.TakerGets.currency, node.PreviousFields.TakerGets.issuer];\n                        get_amnt = node.PreviousFields.TakerGets.value - node.FinalFields.TakerGets.value;\n                    } else {\n                        get_curr = [\"XRP\"];\n                        get_amnt = (node.PreviousFields.TakerGets - node.FinalFields.TakerGets) / 1000000;\n                    }\n\n                    // key includes full date/time to enable searching by time\n                    emit([pay_curr, get_curr].concat(datetime), [pay_amnt, get_amnt]);\n                    emit([get_curr, pay_curr].concat(datetime), [get_amnt, pay_amnt]);\n\n                }\n            }\n        }\n    }\n}",
          "reduce": "function (keys, values, rereduce) {\n\n    if (!rereduce) {\n\n        var stats = {};\n        var first = values[0],\n            first_price = first[0]/first[1];\n        var last = values[values.length - 1],\n            last_price = last[0]/last[1];\n\n        stats.high = first_price;\n        stats.low = first_price;\n\n        stats.start = first_price;\n        stats.end = last_price;\n\n        stats.vwav_numerator = first_price * first[0];\n        stats.vwav_denominator = first[0];\n\n        for (var v = 1, vlen = values.length; v < vlen; v++) {\n            var trade = values[v],\n                rate = trade[0]/trade[1];\n            \n            stats.high = Math.max(stats.high, rate);\n            stats.low = Math.min(stats.low, rate);\n\n            stats.vwav_numerator += rate * trade[0];\n            stats.vwav_denominator += trade[0];\n        }\n\n        stats.volume_weighted_avg = stats.vwav_numerator / stats.vwav_denominator;\n\n        return stats;\n\n    } else {\n\n        var stats = values[0];\n        stats.end = values[values.length - 1].end; // this could be wrong. is this getting the values in order?\n\n        for (var v = 1, vlen = values.length; v < vlen; v++) {\n            var segment = values[v];\n\n            stats.high = Math.max(stats.high, segment.high);\n            stats.low = Math.min(stats.low, segment.low);\n\n            stats.vwav_numerator += segment.vwav_numerator;\n            stats.vwav_denominator += segment.vwav_denominator;\n        }\n\n        stats.volume_weighted_avg = stats.vwav_numerator / stats.vwav_denominator;\n\n        return stats;\n\n    }\n}"
        },
        "sum": {
          "map": "function(doc) {\n  var date = new Date(doc.close_time_timestamp),\n      key = [null, date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours()],\n      transactions = doc.transactions;\n\n  for (var i = 0, n = transactions.length; i < n; ++i) {\n    var t = transactions[i],\n        type = t.TransactionType;\n    if (!type) continue;\n    var pair = type === \"Payment\" ? value(t.Amount)\n          : type === \"TrustSet\" ? value(t.LimitAmount)\n          //: type === \"OfferCreate\" ? value(t.TakerPays) + \"/\" + value(t.TakerGets)\n          : null;\n    if (pair == null) continue;\n    var k = key.slice();\n    k[0] = type;\n    emit(k, pair);\n  }\n}\n\nfunction value(d) {\n  return d.currency ? [+d.value, d.currency] : [+d, \"XRP\"];\n}",
          "reduce": "function(keys, values, rereduce) {\n  var counts = {};\n  if (rereduce) for (var i = 0, n = values.length; i < n; ++i) {\n    var value = values[i];\n    for (var key in value) {\n      if (counts.hasOwnProperty(key)) counts[key] += value[key];\n      else counts[key] = value[key];\n    }\n  } else for (var i = 0, n = values.length; i < n; ++i) {\n    var pair = values[i],\n        value = pair[0],\n        key = pair[1];\n    if (counts.hasOwnProperty(key)) counts[key] += value;\n    else counts[key] = value;\n  }\n  return counts;\n}"
        },
        "total_transactions": {
          "map": "function (doc) {\n    emit(doc.ledger_index, doc.transactions.length);\n}",
          "reduce": "function(keys, values) {\n    return sum(values);\n}"
        },
        "trustlinesByAccount": {
          "map": "function(doc) {\n    for (var t = 0, txs = doc.transactions.length; t < txs; t++) {\n        var tx = doc.transactions[t];\n        for (var n = 0, nodes = tx.metaData.AffectedNodes.length; n < nodes; n++) {\n\n            if (tx.metaData.AffectedNodes[n].hasOwnProperty(\"CreatedNode\") && tx.metaData.AffectedNodes[n].CreatedNode.LedgerEntryType === \"RippleState\") {\n                var cnode = tx.metaData.AffectedNodes[n].CreatedNode;\n\n                var currency = cnode.NewFields.Balance.currency,\n                    high_party = cnode.NewFields.HighLimit.issuer,\n                    low_party = cnode.NewFields.LowLimit.issuer;\n\n                if (parseFloat(cnode.NewFields.LowLimit.value) > 0) {\n                    emit([high_party, currency], {\"incoming\": 1});\n                    emit([low_party, currency], {\"outgoing\": 1});\n                }\n\n                if (parseFloat(cnode.NewFields.HighLimit.value) > 0) {\n                    emit([low_party, currency], {\"incoming\": 1});\n                    emit([high_party, currency], {\"outgoing\": 1});\n                }\n\n                if (parseFloat(cnode.NewFields.Balance.value) !== 0) {\n                    emit([high_party, currency], {\"balance_change\": 0 - parseFloat(cnode.NewFields.Balance.value)});\n                    emit([low_party, currency], {\"balance_change\": parseFloat(cnode.NewFields.Balance.value)});\n                }\n\n            } else if (tx.metaData.AffectedNodes[n].hasOwnProperty(\"ModifiedNode\") && tx.metaData.AffectedNodes[n].ModifiedNode.LedgerEntryType === \"RippleState\") {\n                var mnode = tx.metaData.AffectedNodes[n].ModifiedNode;\n\n                // high limit changed\n                if (mnode.PreviousFields.hasOwnProperty(\"HighLimit\")) {\n\n                    // adding trust line\n                    if (parseFloat(mnode.PreviousFields.HighLimit.value) === 0 && parseFloat(mnode.FinalFields.HighLimit.value) > 0) {\n\n                        var currency = mnode.FinalFields.LowLimit.currency,\n                            trusting_party = mnode.FinalFields.HighLimit.issuer,\n                            trusted_party = mnode.FinalFields.LowLimit.issuer;\n\n                        emit([trusted_party, currency], {\"incoming\": 1});\n                        emit([trusting_party, currency], {\"outgoing\": 1});\n                    }\n\n                    // removing trust line\n                    if (parseFloat(mnode.PreviousFields.HighLimit.value) > 0 && parseFloat(mnode.FinalFields.HighLimit.value) === 0) {\n\n                        var currency = mnode.FinalFields.LowLimit.currency,\n                            trusting_party = mnode.FinalFields.HighLimit.issuer,\n                            trusted_party = mnode.FinalFields.LowLimit.issuer;\n\n                        emit([trusted_party, currency], {\"incoming\": -1});\n                        emit([trusting_party, currency], {\"outgoing\": -1});\n                    }\n\n                }\n\n\n                // low limit changed\n                if (mnode.PreviousFields.hasOwnProperty(\"LowLimit\")) {\n\n                    // adding trust line\n                    if (parseFloat(mnode.PreviousFields.LowLimit.value) === 0 && parseFloat(mnode.FinalFields.LowLimit.value) > 0) {\n\n                        var currency = mnode.FinalFields.HighLimit.currency,\n                            trusting_party = mnode.FinalFields.LowLimit.issuer,\n                            trusted_party = mnode.FinalFields.HighLimit.issuer;\n\n                        emit([trusted_party, currency], {\"incoming\": 1});\n                        emit([trusting_party, currency], {\"outgoing\": 1});\n                    }\n\n                    // removing trust line\n                    if (parseFloat(mnode.PreviousFields.LowLimit.value) > 0 && parseFloat(mnode.FinalFields.LowLimit.value) === 0) {\n\n                        var currency = mnode.FinalFields.HighLimit.currency,\n                            trusting_party = mnode.FinalFields.LowLimit.issuer,\n                            trusted_party = mnode.FinalFields.HighLimit.issuer;\n\n                        emit([trusted_party, currency], {\"incoming\": -1});\n                        emit([trusting_party, currency], {\"outgoing\": -1});\n                    }\n\n                }\n\n                // balance changed\n                if (mnode.PreviousFields.hasOwnProperty(\"Balance\")) {\n\n                    var currency = mnode.FinalFields.Balance.currency,\n                        low_party = mnode.FinalFields.LowLimit.issuer,\n                        high_party = mnode.FinalFields.HighLimit.issuer;\n\n                    emit([low_party, currency], {\"balance_change\": (mnode.FinalFields.Balance.value - mnode.PreviousFields.Balance.value)});\n                    emit([high_party, currency], {\"balance_change\": (0 - (mnode.FinalFields.Balance.value - mnode.PreviousFields.Balance.value))});\n\n                }\n            }\n        }\n    }\n}",
          "reduce": "function (keys, values) {\n    var results = {\"incoming\": 0, \"outgoing\": 0, \"balance_change\": 0};\n\n    for (var v = 0, vlen = values.length; v < vlen; v++) {\n        if (typeof values[v].incoming === \"number\")\n            results.incoming += values[v].incoming;\n        if (typeof values[v].outgoing === \"number\")\n            results.outgoing += values[v].outgoing;\n        if (typeof values[v].balance_change === \"number\")\n            results.balance_change += values[v].balance_change;\n    }\n\n    return results;\n}"
        },
        "trustlinesByCurrency": {
          "map": "function(doc) {\n    for (var t = 0, txs = doc.transactions.length; t < txs; t++) {\n        var tx = doc.transactions[t];\n        for (var n = 0, nodes = tx.metaData.AffectedNodes.length; n < nodes; n++) {\n\n            if (tx.metaData.AffectedNodes[n].hasOwnProperty(\"CreatedNode\") && tx.metaData.AffectedNodes[n].CreatedNode.LedgerEntryType === \"RippleState\") {\n                var cnode = tx.metaData.AffectedNodes[n].CreatedNode;\n\n                var currency = cnode.NewFields.Balance.currency,\n                    high_party = cnode.NewFields.HighLimit.issuer,\n                    low_party = cnode.NewFields.LowLimit.issuer;\n\n                if (parseFloat(cnode.NewFields.LowLimit.value) > 0) {\n                    emit([currency, high_party], {\"incoming\": 1});\n                    emit([currency, low_party], {\"outgoing\": 1});\n                }\n\n                if (parseFloat(cnode.NewFields.HighLimit.value) > 0) {\n                    emit([currency, low_party], {\"incoming\": 1});\n                    emit([currency, high_party], {\"outgoing\": 1});\n                }\n\n                if (parseFloat(cnode.NewFields.Balance.value) !== 0) {\n                    emit([currency, high_party], {\"balance_change\": 0 - parseFloat(cnode.NewFields.Balance.value)});\n                    emit([currency, low_party], {\"balance_change\": parseFloat(cnode.NewFields.Balance.value)});\n                }\n\n            } else if (tx.metaData.AffectedNodes[n].hasOwnProperty(\"ModifiedNode\") && tx.metaData.AffectedNodes[n].ModifiedNode.LedgerEntryType === \"RippleState\") {\n                var mnode = tx.metaData.AffectedNodes[n].ModifiedNode;\n\n                // high limit changed\n                if (mnode.PreviousFields.hasOwnProperty(\"HighLimit\")) {\n\n                    // adding trust line\n                    if (parseFloat(mnode.PreviousFields.HighLimit.value) === 0 && parseFloat(mnode.FinalFields.HighLimit.value) > 0) {\n\n                        var currency = mnode.FinalFields.LowLimit.currency,\n                            trusting_party = mnode.FinalFields.HighLimit.issuer,\n                            trusted_party = mnode.FinalFields.LowLimit.issuer;\n\n                        emit([currency, trusted_party], {\"incoming\": 1});\n                        emit([currency, trusting_party], {\"outgoing\": 1});\n                    }\n\n                    // removing trust line\n                    if (parseFloat(mnode.PreviousFields.HighLimit.value) > 0 && parseFloat(mnode.FinalFields.HighLimit.value) === 0) {\n\n                        var currency = mnode.FinalFields.LowLimit.currency,\n                            trusting_party = mnode.FinalFields.HighLimit.issuer,\n                            trusted_party = mnode.FinalFields.LowLimit.issuer;\n\n                        emit([currency, trusted_party], {\"incoming\": -1});\n                        emit([currency, trusting_party], {\"outgoing\": -1});\n                    }\n\n                }\n\n\n                // low limit changed\n                if (mnode.PreviousFields.hasOwnProperty(\"LowLimit\")) {\n\n                    // adding trust line\n                    if (parseFloat(mnode.PreviousFields.LowLimit.value) === 0 && parseFloat(mnode.FinalFields.LowLimit.value) > 0) {\n\n                        var currency = mnode.FinalFields.HighLimit.currency,\n                            trusting_party = mnode.FinalFields.LowLimit.issuer,\n                            trusted_party = mnode.FinalFields.HighLimit.issuer;\n\n                        emit([currency, trusted_party], {\"incoming\": 1});\n                        emit([currency, trusting_party], {\"outgoing\": 1});\n                    }\n\n                    // removing trust line\n                    if (parseFloat(mnode.PreviousFields.LowLimit.value) > 0 && parseFloat(mnode.FinalFields.LowLimit.value) === 0) {\n\n                        var currency = mnode.FinalFields.HighLimit.currency,\n                            trusting_party = mnode.FinalFields.LowLimit.issuer,\n                            trusted_party = mnode.FinalFields.HighLimit.issuer;\n\n                        emit([currency, trusted_party], {\"incoming\": -1});\n                        emit([currency, trusting_party], {\"outgoing\": -1});\n                    }\n\n                }\n\n                // balance changed\n                if (mnode.PreviousFields.hasOwnProperty(\"Balance\")) {\n\n                    var currency = mnode.FinalFields.Balance.currency,\n                        low_party = mnode.FinalFields.LowLimit.issuer,\n                        high_party = mnode.FinalFields.HighLimit.issuer;\n\n                    emit([currency, low_party], {\"balance_change\": (mnode.FinalFields.Balance.value - mnode.PreviousFields.Balance.value)});\n                    emit([currency, high_party], {\"balance_change\": (0 - (mnode.FinalFields.Balance.value - mnode.PreviousFields.Balance.value))});\n\n                }\n            }\n        }\n    }\n}",
          "reduce": "function (keys, values) {\n    var results = {\"incoming\": 0, \"outgoing\": 0, \"balance_change\": 0};\n\n    for (var v = 0, vlen = values.length; v < vlen; v++) {\n        if (typeof values[v].incoming === \"number\")\n            results.incoming += values[v].incoming;\n        if (typeof values[v].outgoing === \"number\")\n            results.outgoing += values[v].outgoing;\n        if (typeof values[v].balance_change === \"number\")\n            results.balance_change += values[v].balance_change;\n    }\n\n    return results;\n}"
        }
      }
    }
  ]
}